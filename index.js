// Generated by CoffeeScript 1.10.0
(function() {
  var AsyncUglifyJsPlugin, UglifyCSS, UglifyJS, crypto, debug, fs, isStale, log, md5, minimizeTask, options, path, scheduleMinification, timers,
    slice = [].slice;

  crypto = require('crypto');

  fs = require('fs');

  path = require('path');

  UglifyJS = require('uglify-js');

  UglifyCSS = require('uglifycss');

  timers = {};

  options = {
    delay: 5000,
    minifyOptions: {},
    logger: false,
    done: function(path, originalContents) {
      return log("minimized " + path);
    },
    debug: false
  };

  log = function() {
    var msg;
    msg = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (options.logger) {
      return console.log.apply(console, msg);
    }
  };

  debug = function() {
    var msg;
    msg = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (options.debug) {
      return console.log.apply(console, msg);
    }
  };

  md5 = function(buffer) {
    var content, hash;
    content = buffer.toString();
    hash = crypto.createHash('md5');
    hash.update(content);
    return hash.digest('hex');
  };

  isStale = function(chunk) {
    var hash, stale;
    hash = md5(fs.readFileSync(chunk.path));
    stale = hash !== chunk.fullhash;
    if (stale) {
      log("minification cancelled (file has changed!) " + chunk.path);
    }
    return stale;
  };

  minimizeTask = function(chunk) {
    return function() {
      return fs.readFile(chunk.path, function(err, buffer) {
        var contents, result;
        if (err) {
          throw err;
        }
        if (isStale(chunk)) {
          return;
        }
        log("starting minification " + chunk.path);
        contents = buffer.toString();
        result = /.js$/.test(chunk.path) ? UglifyJS.minify(contents, options.minifyOptions).code : UglifyCSS.processString(contents, options.minifyOptions);
        return fs.writeFile(chunk.path, result, function(err) {
          if (err) {
            throw err;
          }
          return options.done(chunk.path, contents);
        });
      });
    };
  };

  scheduleMinification = function(file, delay) {
    var chunk;
    chunk = {
      id: file,
      file: file
    };
    clearTimeout(timers[chunk.id]);
    chunk.path = path.resolve(options.outputPath, chunk.file);
    return fs.readFile(chunk.path, function(err, buffer) {
      chunk.fullhash = md5(buffer);
      return timers[chunk.id] = setTimeout(minimizeTask(chunk), options.delay);
    });
  };

  AsyncUglifyJsPlugin = (function() {
    function AsyncUglifyJsPlugin(_options) {
      var option, value;
      if (_options == null) {
        _options = {};
      }
      for (option in _options) {
        value = _options[option];
        options[option] = value;
      }
      options.minifyOptions.fromString = true;
    }

    AsyncUglifyJsPlugin.prototype.apply = function(compiler) {
      var previousHash;
      options.outputPath = compiler.options.output.path || '.';
      previousHash = null;
      return compiler.plugin('done', function(stats) {
        var chunk, file, i, j, len, len1, ref, ref1;
        stats = stats.toJson();
        if (previousHash !== stats.hash) {
          debug("schedule minification");
          ref = stats.chunks;
          for (i = 0, len = ref.length; i < len; i++) {
            chunk = ref[i];
            ref1 = chunk.files;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              file = ref1[j];
              scheduleMinification(file);
            }
          }
          return previousHash = stats.hash;
        }
      });
    };

    return AsyncUglifyJsPlugin;

  })();

  module.exports = AsyncUglifyJsPlugin;

}).call(this);
